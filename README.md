# Calculus Function Analyzer Tool
Alivia Glynn, William Cordor  \
Data Structures  \
Final Project Report  \
12/11/2024


## Where did you get the idea for the project?

This project was an original idea developed through brainstorming various project ideas that would best fulfill the project requirements and that had a relation to mathematical concepts, as we both have an interest and extensive knowledge in math, especially calculus. We landed on the final idea of creating a tool that completes calculus-related calculations because we knew we wanted the program to implement higher-level equation-solving and because we wanted it to be a genuinely useful tool that could be used to help students in their calculus courses, especially as that is a requirement for a Computer Science Major. The decision to have the program not only be a calculator but also act as a teacher by providing step-by-step explanations on how and why each calculation occurs finalized our project idea and was suggested to us during our project proposal presentation.

## Main Idea

The project's main idea is to calculate and teach various calculus functions to a user looking to better their understanding of calculus concepts. The user is prompted with a menu that allows them to select a function. There are four functions where each one’s derivative can be solved using varying derivative rule properties. There is a function that can be solved using the power rule, the product rule, the chain rule, and the quotient rule. We decided to implement these specific functions as these are the core rules taught when learning how to solve for derivatives that can also be applied to more challenging derivative calculations. The project solves each function’s derivative and displays output messages that teach the user how to solve the specific function via the according derivative rule. The rest of the calculations performed by the program follow a similar pattern. The second derivative, the limit, the definite integral, and the inflection points can also be solved for each function and they display a teaching output message to the user. A graph of each function is also displayed to further teach by showcasing what the user just calculated visually. The overall objective is a program that can evaluate, analyze, and output key calculus properties for user-defined functions in a straightforward and interactive way that educates the user on key calculus operations.

## Specific tasks of the project

The project contains seven specific tasks. The first task the project completes is calculating the first derivative and second derivative of the selected function. The symbolic derivative is first displayed and then followed by a numerical derivative at an x-value inputted by the user. The user is taught how to solve for that specific function’s derivative based on the derivative rule it requires to be solved by.

The second task evaluates if the limit exists and solves for the limit of the selected function as it approaches an x-value inputted by the user. Its output message will display the limit paired with how that limit was solved for, whether by direct substitution, L’Hopital’s rule, or, through numerical evaluation and downward iteration.

The third task solves for the definite integral of the selected function at the lower bound and the upper bound that is inputted by the user. Its output message then teaches the user how to solve for a definite integral on their own using the Trapezoidal Rule.

The fourth task solves for the inflection points of the selected function from a range and step value inputted by the user. Its output message teaches the user how to solve for an inflection point on their own by setting the second derivative equal to zero and solving for x.

The fifth task saves the results to a text file so the user has a saved form of their calculation history that they can look back through and use to further study and learn the calculus concepts.

The sixth task produces a graph of the selected function customized by the range and step size as inputted by the user that also displays where the inflection point is found on the graph with its coordinate point.

When results are saved, the user is met with three options: choose another function, exit the program, or gain access to the files. 

If the files option is selected, the user will be met with another menu that prompts the user to select how they want to access their files. Users can open their file by typing in their name. Once the name is entered and a file with that name is confirmed to be on the user’s device, the file is opened in a text editor, and the index of said file is output, which leads to the second option. Since the user now knows the index of the file, instead of entering their full name to open a file, the user can now simply enter the index number, and the text editor will open.

## Data Structures Used

Within the program, we used two different data structures. The first data structure we used was lists. We used the list List<Function<Double, Double>> to store the mathematical functions that the user can select from. Each function in the list represents a different type of mathematical expression (e.g., a polynomial, a product of functions, or a quotient) that can be differentiated, integrated, or analyzed. The list structure allows for simple indexing and retrieval of functions based on the user's choice in the interface. We also implemented the list List<String> to provide human-readable descriptions for each function, such as "f(x) = x^3 + 3x^2 - x", ensuring clarity in the user interface and saved results as well as the ability to add new functions to our lists without significant code changes. The second data structure we used within our project was a map. The map Map<Integer, List<String>> tracks the history of calculations performed for each function.  For example, if a user calculates the derivative and limit of a function, these results are stored in the map under the function's key. This structure enables efficient retrieval of all calculations related to a specific function and ensures that the history is well-organized and easy to save or display. In the CalculatorTool Class, the functions and functionDescriptions list are accessed through the getFunctions() method to allow for the management of the mathematical functions throughout the entire class. The functionHistory map is also heavily integrated into the program's logic to store and organize results, enabling a seamless user experience when reviewing or saving calculations. In the CalculusUI, the user selects functions from the list by their index, and the corresponding function is retrieved from the functions list in the CalculatorTool class. The history associated with each function, stored in the functionHistory map, is accessed to display past calculations or write them to a file. Overall, these data structures maintain the program's scalability and ease of use.

## Algorithms and Methods

The program employs a combination of mathematical algorithms and computational methods to perform calculus operations and organize user interactions. The Classes begin with their appropriate constructors and then getter and setter methods to initiate and make things accessible for further use in other methods and classes. In the CalculusTool Class, the first mathematical method is the numerical differentiation method for the first and second derivatives, calculateNumericalFirstDerivative and calculateNumericalSecondDerivative. This method provides an approximation of the derivative of a function at a given point using the derivative definition formula: f′(x)=(f(x+h)−f(x−h))/h paired with the selected function. In these methods, variable h is initialized to a very small value, 10^(-5), to get the closest approximate value. There are then the symbolic derivative methods, calculateSymbolicFirstDerivative and calculateSymbolicSecondDerivative. These methods hold the manually implemented derivatives along with their teaching lessons. A switch statement is used to identify the currently selected function by its index held in selectedFunctionIndex which then provides the corresponding symbolic differentiation logic for that specific function. There is then outputted a clear, human-readable explanation of how the derivative is calculated, based on calculus rules such as the power rule, product rule, quotient rule, and chain rule.

There are then four methods to calculate a function's limit as there are varying ways to solve for limits. The approach to creating these methods was similar to that of the derivatives, taking calculus algorithms, properties, and rules and applying them logistically to find the limit for various functions. The calculateLimit function is the primary entry point for the limit calculation. It determines the appropriate method to compute the limit based on the input function and point. It starts by evaluating the left-hand limit (f(x - h)) and right-hand limit (f(x + h)), where h is a small step size. If the absolute difference between the two values is smaller than a defined tolerance or that small h size, the method concludes that the limit exists and approximates its value by plugging in the x value inputted by the user into the selected function. If the numerical approach detects an indeterminate case like 0/0 or an undefined value by using the isInderterminate method that checks if the numerator is less than the small h value, the method switches to L'Hopitals rule or other fallback methods. The solveUsingLHopital method first checks if the function's limit at the specified point results in an indeterminate form by evaluating the numerator and denominator separately. If an indeterminate form is detected, the method uses the program’s symbolic differentiation logic to compute the derivatives of the numerator and denominator. The limit is then recalculated with these derivatives. If the result remains indeterminate, the method recursively applies L'Hôpital's Rule up to a maximum recursion depth to avoid infinite loops. If the recursion depth is exceeded, a fallback numerical approximation is used as a last resort. This brings us to the calculateLimitNumerically method that approximates the limit of a function when symbolic differentiation or L'Hôpital's Rule cannot resolve it. The method computes the left-hand and right-hand limits f(x−h) and f(x+h)) using an initial step size h and comparing their values. If the absolute difference is smaller than a defined tolerance, the limit is considered convergent. Otherwise, the step size h is halved, and the method calls itself recursively to refine the approximation. 

The next method is calculateDefiniteIntegral which uses the trapezoidal rule, an approximation method that divides the area under the curve into trapezoids and sums their areas  So the formula (b-a)*1/2(f(a)+f(b)) is implemented by getting the bounds a and b from the user. A for loop runs n times, once for each trapezoid, and the selected function from the first endpoint added to the second endpoint is multiplied by .5 and summed each iteration to get to the total area.

The findInflectionPoints method gets the second derivative of the selected function and checks the concavity before and after by using the central derivative formula f(x+h)-2f(x)+f(x+h)/2h and plugging in the step for h. If the sign values, negative or positive, for these results are not equal then there is an inflection point as concavity changes so an inflection point is added at that x value.

The plotFunction method relies on the referenced library jfreeChart to plot the function across a given range. The x-values are iterated across the range, and the corresponding y-values are computed using the selected function. The title, axes and legends are set. Inflection points are marked on the graph for visual clarity using the same inflection logic from findInflectionPoints and XYPlot is utilized to plot them on the graph. The chart is then displayed in a swing window for better visuals.

Lastly, for the CalculatorTool class, the saveResultsToFile method is responsible for saving the user's calculations to a text file in an organized and readable format. The file name is generated using the user's first and last name, a BufferedWriter is used to write to the file efficiently and the try-with-resources block ensures that the file is properly closed after writing. A header is given to the file and the functionHistory map is iterated to retrieve each function's index and its associated calculation history and then all calculations for the selected function are written under its description, providing a detailed record of user activity.

The first method in the CalculatorUI class is mainMenu(). mainMenu() is the main method that the user will interact with. All methods in the project are implemented in mainMenu() in some type of way. collectUserInfo() is the first method called from mainMenu(), which prompts the user to enter their first and last names.

Once names are entered, the second method called is selectFunction(), which tells the user to choose which function they’d like to learn about. selectFunction() uses getFunctions() and selectFunction(int index) from the CalculatorTool class to display the list of functions to choose from.

When a function is selected, the user now has the option to either perform a calculation, or graph a function. A switch statement is used for this as well as a while loop so that the user can perform as many calculations or create as many graphs as they want without having to restart the code.

Choosing to perform a calculation will result in performCalculation() being called. From performCalculation(), a menu of user-friendly mathematical tutorials is shown. The user chooses which tutorial to see. A switch statement is used to access the chosen tutorial. Methods from CalculatorTool are helped to compute the tutorials. calculateSymbolicFirstDerivative(), calculateNumericalFirstDerivative(double x) and addCalculationToHistory(String calculation) are used in the tutorial of finding the first derivative. For the second derivative tutorial, calculateSymbolicSecondDerivative(), calculateNumericalSecondDerivative(double x) are used as well as addCalculationToHistory(String calculation) again. For both the first and second derivative tutorials, the user is prompted to enter any number from the double data type. The number is then plugged into the updated function and the result is returned as well as the tutorial for how it was found. For finding the limit of a function, calculateLimit(double x) is called upon. The user is tasked with entering an x value which will be used to calculate the limit at the given x value. The tutorial for definite integrals prompts for the user to enter two values, the start point and the end point. From there, calculateDefiniteIntegral(double a, double b) is called, using the two values entered by the user as arguments, and calculates the definite integral between the two values. The last tutorial involves inflection points. Here, the user is prompted to enter three values: the range start, range end, and step size. These three double values are taken and used as arguments when findInflectionPoints(double start, double end, double step) is called to calculate where the inflection points will be on a graph. There’s also a sixth option, which is to return back to the functions menu to choose another function. When the user has seen a tutorial, the user is met with an option to save the results or choose another calculation. In a switch statement, if the user chooses to save the results, the CalculusUI method saveResultsToFile() is called upon, which in itself calls upon the CalculatorTool method saveResultsToFile(String firstName, String lastName), which creates a text file in the user’s device of the functions, tutorials and values that the user selected. 

After an option is chosen, the next statement is a while loop that calls performCalculation() depending on if the user decided to choose another calculation. Once a calculation is chosen, the while loop terminates. 

The last part of mainMenu() is an if statement. If a calculation has been done and saved as a text file, the user is met with the options of choosing another function, accessing the files on their device, or exiting the program. This is allowed by way of a switch statement. If the user chooses the files option, files() is called. files() is a method in CalculusUI that shows the user a menu of how they want to access their files. There may be a case in real-life where multiple people are using the same pc and want to use the same program. The first option is to find the file index, which calls the searchName(File[] directory, String fileName) method from the FileAccessor class. searchName() works as a linear search algorithm that searches through file directories to find the index of the file in question. When results are saved to a text file, that file is automatically placed in the directory C:\CalcResults. searchName() prompts the user to enter their first and last name, and if the name matches file name format ‘firstname_lastname_Calculus.txt’, the index number will be output and the file will be opened. For future uses, since the user now knows the index of their file, the user can select the second option, which is to open the file by entering the index of their file. When this option is chosen, the FileAccessor class openFile(File[] list) is called. openFile() asks the user to enter the index number of their file, the index number is smaller than the number of files in C:\CalcResults, the file will open. The third option, to exit the program, sets the boolean variable ‘exit’ to true, and a statement thanking the user for using the program is output. Most of mainMenu() is a while loop that depends on ‘exit’ being false. When it is flipped to true, the while loop terminates, then mainMenu(), and then the main method in the Main class.

## Challenges and Possible Future Work

One of the primary challenges faced during the development of the program was implementing the graphing functionality. Although the JFreeChart library was ultimately used, initial attempts at plotting mathematical functions were complicated by the need to dynamically represent user-selected functions and annotate specific points like inflection points. Another significant challenge was the critical point detection. Despite numerous attempts and extensive debugging, the calculations did not consistently produce correct results, leading to the decision to replace this functionality with inflection point detection, which proved more feasible and reliable. The limit calculation was the most demanding aspect of the project, requiring multiple algorithms and fallback strategies to handle cases like direct substitution, indeterminate forms, and numerical approximations. This required intensive testing and recursive logic to achieve accuracy. Another challenge for this project was coming up with a searching method that related to the project. The idea for it to be file-related was clear but for a while, it was unknown how it would be helpful to the user or what searching algorithm would be used. The program successfully fulfills its goal of being both a computational tool and a teaching resource. It provides users with step-by-step guidance for solving calculus problems, including derivatives, integrals, limits, and inflection points, while offering visualization through graphs. The structured use of classes and data structures ensures the program's scalability and modularity. For future work, additional functions could be added to the list to expand the program's educational scope and utility. More advanced calculus topics, such as series approximations or partial derivatives, could be introduced. Improving the visual clarity of the graphs and integrating more robust error handling for user inputs would also enhance the program's usability. This project has laid a solid foundation for a comprehensive calculus teaching tool, and its current success suggests great potential for further development.

## Work Distribution

Alivia worked on the CalculusTool class and William worked on the FileAccessor class. The CalculusUI class was implemented collaboratively, as was the debugging, testing, and finalization of the project.

## Works Cited

Codecademy. (n.d.). Math methods: signum. Codecademy. Retrieved from https://www.codecademy.com/resources/docs/java/math-methods/signum

Khan Academy. (n.d.). Understanding the trapezoid rule. Khan Academy. Retrieved from https://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/a/understanding-the-trapezoid-rule

BYJU's. (n.d.). Inflection point. BYJU's. Retrieved from https://byjus.com/maths/inflection-point/

GeeksforGeeks. (n.d.). Java program to create a new file. GeeksforGeeks. Retrieved from https://www.geeksforgeeks.org/java-program-to-create-a-new-file/

W3Schools. (n.d.). Java files: Create a file. W3Schools. Retrieved from https://www.w3schools.com/java/java_files_create.asp

Tutorialspoint. (n.d.). JFreeChart. Tutorialspoint. Retrieved from https://www.tutorialspoint.com/jfreechart/index.htm

Holoborodko, P. (n.d.). Central differences. Retrieved from http://www.holoborodko.com/pavel/numerical-methods/numerical-derivative/central-differences/

Oracle. (n.d.). Math (Java SE 12 & JDK 12 documentation). Oracle. Retrieved from https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Math.html

Joe23Joe235, et al. “Difference between File.Separator and Slash in Paths.” Stack Overflow, 1 Apr. 1955, stackoverflow.com/questions/2417485/difference-between-file-separator-and-slash-in-paths. 
“Open a File in Java.” Www.Javatpoint.Com, www.javatpoint.com/how-to-open-a-file-in-java. Accessed 11 Dec. 2024.  
jimmyjimmy8, et al. “How to Create a Directory in Java?” Stack Overflow, 1 Oct. 1955, stackoverflow.com/questions/3634853/how-to-create-a-directory-in-java. 

